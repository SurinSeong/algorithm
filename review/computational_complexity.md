# 계산 복잡도
- 대문자 O 표기법을 계산이 간단한 것에서 복잡한 것 순으로 정리

1. O(1) : 입력 크기 n과 계산 복잡도가 무관할 때  
    ex) 계산 공식 n(n+1)/2를 이용한 1부터 n까지의 합

2. O(logN) : 입력 크기 n의 로그 값에 비례하여 계산 복잡도가 증가할 때  
    ex) 이분 탐색

3. O(n) : 입력 크기 n에 비례하여 계산 복잡도가 증가할 때  
    ex) 최댓값 찾기, 순차 탐색

4. O(NlogN) : 입력 크기 N과 logN의 곱에 비례하여 계산 복잡도가 증가할 때  
    ex) 병합 정렬, 퀵 정렬

5. O(n^2) : 입력 크기 n의 제곱에 비례하여 계산 복잡도가 증가할 때  
    ex) 선택 정렬, 삽입 정렬

6. O(2^n) : 입력 크기가 n일 때, 2의 n제곱 값에 비례하여 계산 복잡도가 증가할 때  
    ex) 하노이의 탑

---

※ for 반복문 중첩 여부에 따른 계산 복잡도 차이

1. for 반복문이 겹쳤을 경우
```
for i in range(0, n-1):
    for j in range(i+1, n):
        # 중첩된 반복 부분
```
- 실행 횟수 : n(n-1)/2
- 계산 복잡도 : O(n^2)

2. for 반복문이 겹치지 않은 경우
```
for i in range(0, n):
    # 반복 1: 이 부분은 n번 실행
for i in range(0, n):
    # 반복 2: 이 부분은 n번 실행
```
- 실행 횟수 : 2n
- 계산 복잡도 : O(n)

---

## 시간 복잡도와 공간 복잡도

- 딕셔너리를 이용해 동명이인을 찾는 문제는 모든 사람을 서로 비교하는 방법보다 더 나은 시간 복잡도를 가짐
- 하지만, 딕셔너리를 만들어 그 안에 모든 이름과 등장 횟수를 저장해야 하므로 더 많은 저장 공간을 사용  
=> 공간 복잡도를 희생해 시간 복잡도를 개선

- 알고리즘 분석을 정확하게 하기 위해서는 **시간 복잡도 + 공간 복잡도** 고려 필요  
(공간 복잡도에 덜 민감한 편이긴 하다.)